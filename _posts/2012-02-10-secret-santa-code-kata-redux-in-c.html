---
layout: post
title: Secret Santa Code Kata Redux in C#
date: 2012-02-10 22:03:27.000000000 -07:00
categories:
- coding
- professional
tags:
- c-sharp
- C#
- code exercise
status: publish
type: post
published: true
meta:
  _syntaxhighlighter_encoded: '1'
  tumblr_agiletapir_permalink: http://agiletapir.tumblr.com/post/17346538232/secret-santa-code-kata-redux-in-c
  tumblr_agiletapir_id: '17346538232'
  _wp_old_slug: '17346538232'
  _edit_last: '5'
  _jetpack_related_posts_cache: a:1:{s:32:"8f6677c9d6b0f903e98ad32ec61f8deb";a:2:{s:7:"expires";i:1436729289;s:7:"payload";a:3:{i:0;a:1:{s:2:"id";i:527;}i:1;a:1:{s:2:"id";i:1255;}i:2;a:1:{s:2:"id";i:43;}}}}
author:
  login: Chuck
  email: chuck@neontapir.com
  display_name: Chuck
  first_name: Chuck
  last_name: Durfee
excerpt: !ruby/object:Hpricot::Doc
  options: {}
---
<p>Here’s another solution to the <a href="http://rubyquiz.com/quiz2.html">Secret Santa code kata</a>, this time in my “native” programming language of C#. This is the second solution I’ve written this week to this problem. Code katas are about experimenting with different approaches to simple but not trivial problems.</p>
<p>My <a href="http://neontapir.com/wp/2012/01/secret-santa-code-kata-in-powershell/">first solution</a>, written in PowerShell, relied on selecting random pairs of people and using a “hill-climbing” algorithm to avoid getting stuck. This time, I gave myself the constraint that the solution had to be deterministic — no randomness. I had been toying with the idea of using an Abelian <a href="http://en.wikipedia.org/wiki/Ring_(mathematics)">ring</a>. A couple of common examples are the hours on a clock or the modulus (remainder) operator in math. But I couldn’t decide how I’d handle iterating through the members of that ring without duplicates. I determined that I’d need to re-sort the list.</p>
<p>I wrote this solution using test-driven development (TDD), meaning I wrote my tests before implementation — I won’t show all of those tests today. As it turned out, I didn’t need to code a Ring class. I find when I do TDD, I often don’t end up writing half the code I thought I’d need!</p>
<p>Unlike my PowerShell solution which just used strings, I knew I wanted to create a data object to store the incoming rows of data in, which I named the Participant class:</p>
<p>[sourcecode language="csharp" collapse="true"]<br />
using System;</p>
<p>namespace SantaKataApp<br />
{<br />
    public class Participant<br />
    {<br />
        private Participant(string firstName, string lastName, string email)<br />
        {<br />
            FirstName = firstName;<br />
            LastName = lastName;<br />
            Email = email;<br />
        }</p>
<p>        public string FirstName { get; private set; }<br />
        public string LastName { get; private set; }<br />
        public string Email { get; private set; }</p>
<p>        public static Participant Create(string descriptor, int id)<br />
        {<br />
            var parts = descriptor.Split();<br />
            var email = parts[2].Replace(&quot;&amp;lt;&quot;, &quot;&quot;).Replace(&quot;&amp;gt;&quot;, &quot;&quot;);<br />
            return new Participant(parts[0], parts[1], email);<br />
        }</p>
<p>        public override string ToString()<br />
        {<br />
            return string.Format(&quot;{0} {1} &amp;lt;{2}&amp;gt;&quot;, FirstName, LastName, Email);<br />
        }<br />
    }<br />
}<br />
[/sourcecode]</p>
<p>For a while, I thought I might need to implement <code>IEquatable&lt;Participant&gt;</code>, <code>Equals()</code>, and <code>GetHashCode()</code> in order to compare Participants, but again, TDD proved me wrong.</p>
<p>The plan for this approach was to:<br />
1. Parse the incoming list<br />
2. Resort the list<br />
3. Display the results</p>
<p>The act of resorting took the majority of the development time. I created a <code>ListResorter</code> class to do the work.</p>
<p>I started by writing tests….</p>
<p>[sourcecode language="csharp" collapse="true"]<br />
using System;<br />
using System.Collections;<br />
using System.Collections.Generic;<br />
using System.Linq;<br />
using Microsoft.VisualStudio.TestTools.UnitTesting;<br />
using SantaKataApp;</p>
<p>namespace SantaKataTests<br />
{<br />
    [TestClass]<br />
    public class ListResorterTests<br />
    {<br />
        [TestMethod]<br />
        public void SwapItemsInList_Succeeds()<br />
        {<br />
            var list = new List&amp;lt;int&amp;gt;(new[] { 3, 2, 1 });<br />
            var listResorter = new ListResorter&amp;lt;int&amp;gt;(list, null);<br />
            listResorter.Swap(0, 1);<br />
            CollectionAssert.AreEqual(list.ToArray(), new[] { 2, 3, 1 });<br />
        }</p>
<p>        [TestMethod, ExpectedException(typeof(InvalidOperationException))]<br />
        public void SwapWithInvalidIndex_Throws()<br />
        {<br />
            var list = new List&amp;lt;int&amp;gt;(new[] { 3, 2, 1 });<br />
            var listResorter = new ListResorter&amp;lt;int&amp;gt;(list, null);<br />
            listResorter.Swap(74, 1);<br />
        }</p>
<p>        [TestMethod]<br />
        public void CanAdjoin_WithTwoItems_DeterminesIfTheyCanAdjoin()<br />
        {<br />
            var list = new List&amp;lt;int&amp;gt;(new[] { 3, 1, 2 });<br />
            var listResorter = new ListResorter&amp;lt;int&amp;gt;(list, (x,y) =&amp;gt; x % 2 != y % 2);<br />
            Assert.IsTrue(listResorter.CanAdjoin(1, 2)); // list[1] = 1, list[2] = 2<br />
            Assert.IsFalse(listResorter.CanAdjoin(0, 1));<br />
        }</p>
<p>        // ... and so on ...<br />
    }<br />
}<br />
[/sourcecode]</p>
<p>These are the first two tests I wrote. I decided the simplest operation I needed to resort a list was the ability to swap two items in that list. Once I had that working, I picked the next piece, the ability to decide if two things can adjoin (“to be close to or in contact with”), and I proceeded from there.</p>
<p>Notice that the <code>LineResorter&lt;T&gt;</code> constructor takes a list to operate against, and a function that compares two instances of type T and determines if they can be adjoining in the list. In the case of my unit tests, I used <code>(x,y) =&gt; x % 2 != y % 2</code>, which is a fancy way of saying that two odds or two evens can’t be next to each other in the list. I wanted to use a different type (int) than I’d be using in my real use case to make sure I didn’t make any assumptions about the nature of type T. This comparison was the first one for two numbers that came to mind.</p>
<p>Each time I needed functionality out of the <code>ListResorter</code>, I wrote a test. I watched it fail, then I made all the tests pass. If I saw opportunities to refactor, I took them whenever all my tests were green (passing). By the time I was done, I had about a dozen tests and this class:</p>
<p>[sourcecode language="csharp" collapse="true"]<br />
using System;<br />
using System.Collections.Generic;<br />
using System.Linq;</p>
<p>namespace SantaKataApp<br />
{<br />
    public class ListResorter&amp;lt;T&amp;gt;<br />
    {<br />
        private readonly List&amp;lt;T&amp;gt; _list;<br />
        private readonly Func&amp;lt;T, T, bool&amp;gt; _canAdjoin;</p>
<p>        public ListResorter(List&amp;lt;T&amp;gt; list, Func&amp;lt;T, T, bool&amp;gt; canAdjoin)<br />
        {<br />
            _list = list;<br />
            _canAdjoin = canAdjoin;<br />
        }</p>
<p>        internal void Swap(int index1, int index2)<br />
        {<br />
            ThrowIfIndexesAreInvalid(index1, index2);<br />
            T temp = _list[index2];<br />
            _list[index2] = _list[index1];<br />
            _list[index1] = temp;<br />
        }</p>
<p>        private void ThrowIfIndexesAreInvalid(int index1, int index2)<br />
        {<br />
            if (_list.Count &amp;lt; index1 - 1 || _list.Count &amp;lt; index2 - 1)<br />
                throw new InvalidOperationException(&quot;An index is beyond the length of the array&quot;);<br />
        }</p>
<p>        internal bool CanAdjoin(int index1, int index2)<br />
        {<br />
            ThrowIfIndexesAreInvalid(index1, index2);<br />
            return _canAdjoin(_list[index1], _list[index2]);<br />
        }</p>
<p>        public int GetNextIndex(int i)<br />
        {<br />
            if (i &amp;gt;= _list.Count)<br />
                throw new InvalidOperationException(&quot;Invalid index&quot;);<br />
            if (i == _list.Count - 1)<br />
                return 0;<br />
            return i + 1;<br />
        }</p>
<p>        internal bool CanAllAdjoin()<br />
        {<br />
            return !_list.Where((t, i) =&amp;gt; !CanAdjoin(i, GetNextIndex(i))).Any();<br />
        }</p>
<p>        public List&amp;lt;T&amp;gt; Resort()<br />
        {<br />
            var list = _list;</p>
<p>            while (! CanAllAdjoin())<br />
            {<br />
                for (int i=0; i &amp;lt; list.Count; i++)<br />
                {<br />
                    int j = GetNextIndex(i);<br />
                    int k = GetNextIndex(j);<br />
                    if (! CanAdjoin(i, j) &amp;amp;&amp;amp; CanAdjoin(i, k))<br />
                        Swap(j, k);<br />
                }<br />
            }<br />
            return list;<br />
        }<br />
    }<br />
}<br />
[/sourcecode]</p>
<p>This class has two public methods, <code>GetNextIndex()</code> and <code>Resort()</code>. That Abelian ring idea still lives in the <code>GetNextIndex()</code> method, which says that the next member after the last in the list is the first, making the list circular. <code>Resort()</code> does what you would expect.</p>
<p>The other methods in the class are marked internal, so that my TDD tests can access them via the <code>[Assembly:InternalsVisibleTo()]</code> attribute in the <code>Assembly.cs</code> code file. After design is done, I would consider rewriting the test methods that talk to internal methods so that they are exercised through the public method. I don’t want my unit tests to be break should someone decide to change the internal implementation of these methods. You can see a bit of this thinking in the <code>ThrowIfIndexesAreInvalid()</code> method. I pulled this method out to avoid duplication of code during refactoring, where I already had unit tests in place and thus I didn’t need to write new ones.</p>
<p>Once I had <code>ListResorter</code> working, writing a console wrapper was easy:</p>
<p>[sourcecode language="csharp" collapse="true"]<br />
using System;<br />
using System.Collections.Generic;<br />
using System.IO;<br />
using System.Linq;</p>
<p>namespace SantaKataApp<br />
{<br />
    class Program<br />
    {<br />
        static void Main(string[] args)<br />
        {<br />
            string[] fileContents = File.ReadAllLines(args[0]);<br />
            Func&amp;lt;Participant, Participant, bool&amp;gt; surnamesDontMatch = (x, y) =&amp;gt; x.LastName != y.LastName;<br />
            List&amp;lt;Participant&amp;gt; names = fileContents.Select(Participant.Create).ToList();</p>
<p>            var listResorter = new ListResorter&amp;lt;Participant&amp;gt;(names, surnamesDontMatch);<br />
            List&amp;lt;Participant&amp;gt; sorted = listResorter.Resort();</p>
<p>            DisplayParticipants(listResorter, sorted);<br />
        }</p>
<p>        internal static void DisplayParticipants(ListResorter&amp;lt;Participant&amp;gt; listResorter, IList&amp;lt;Participant&amp;gt; sorted)<br />
        {<br />
            for(int i=0; i &amp;lt; sorted.Count; i++)<br />
                Console.WriteLine(Display(sorted[i], sorted[listResorter.GetNextIndex(i)]));<br />
        }</p>
<p>        internal static string Display(Participant name, Participant giveToName)<br />
        {<br />
            var giveTo = giveToName != null ? giveToName.ToString() : &quot;NONE&quot;;<br />
            return string.Format(&quot;{0} gives a gift to {1}&quot;, name, giveTo);<br />
        }<br />
    }<br />
}<br />
[/sourcecode]</p>
<p>Most of the work done in the console app is formatting the output for display. The heavy lifting is done by the <code>ListResorter</code> class.</p>
<p>This program outputs data like:</p>
<pre>PS C:temp&gt; .SantaKataApp.exe .names_santa.txt
Luke Skywalker &lt;luke@theforce.net&gt; gives a gift to Toula Portokalos &lt;toula@manhunter.org&gt;
Toula Portokalos &lt;toula@manhunter.org&gt; gives a gift to Leia Skywalker &lt;leia@therebellion.org&gt;
Leia Skywalker &lt;leia@therebellion.org&gt; gives a gift to Gus Portokalos &lt;gus@weareallfruit.net&gt;
...</pre>
<p>I met my goal: the output is the same every time given the same input file.</p>
<p>I time-boxed the effort at two hours and I came close to reaching my limit. I initially began by writing an iterator, but abandoned it when I realized that I only wanted to traverse the collection once.</p>
<p>There is more that could be done to this program, of course. For example, I’m not happy about <code>DisplayParticipants</code> using <code>GetNextIndex()</code>. The only reason that <code>DisplayParticipants()</code> needs a <code>ListResorter</code> is to use its ring-like <code>GetNextIndex()</code> method. This functionality should have been extracted into its own class.</p>
<p>Comments? Questions?</p>

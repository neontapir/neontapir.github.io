---
layout: post
title: '"Secret Santa" Code Kata in Powershell'
date: 2012-01-25 21:36:48.000000000 -07:00
categories:
- coding
- professional
tags:
- code exercise
- powershell
status: publish
type: post
published: true
meta:
  _syntaxhighlighter_encoded: '1'
  tumblr_agiletapir_permalink: http://agiletapir.tumblr.com/post/16507339374/secret-santa-code-kata-in-powershell
  tumblr_agiletapir_id: '16507339374'
  _wp_old_slug: '16507339374'
  _edit_last: '5'
  _jetpack_related_posts_cache: a:1:{s:32:"8f6677c9d6b0f903e98ad32ec61f8deb";a:2:{s:7:"expires";i:1438228054;s:7:"payload";a:3:{i:0;a:1:{s:2:"id";i:528;}i:1;a:1:{s:2:"id";i:531;}i:2;a:1:{s:2:"id";i:532;}}}}
author:
  login: Chuck
  email: chuck@neontapir.com
  display_name: Chuck
  first_name: Chuck
  last_name: Durfee
excerpt: !ruby/object:Hpricot::Doc
  options: {}
---
<p>The team at work is doing a Code Kata, <a href="http://rubyquiz.com/quiz2.html">the Secret Santa kata from Ruby Quiz</a>. In it, you are given a list of names and emails and need to pair givers with receivers, with the only constraint being that a giver and receiver can’t have the same surname.</p>
<p>I wrote my solution in PowerShell. I wanted to use native PowerShell functionality, so I didn’t import any .NET libraries. I know this post is brief, but I wanted to get my solution posted with a little commentary while it was still fresh in my mind.</p>
<p>When run like this:</p>
<pre><code>PS&gt; .santa.ps1 .names.txt </code></pre>
<p>It gives output like:</p>
<pre><code>Giver Receiver ----- --------- John Smith &lt;jsmith@example.com&gt; Jane Doe &lt;jdoe@example.com&gt; ... </code></pre>
<p>Here’s the code:</p>
<p>[sourcecode language="powershell" collapse="true"]<br />
 param($file)</p>
<p> function ConvertTo-Array($hashtable)<br />
 {<br />
     $result = @()<br />
     $hashtable.GetEnumerator() | % {<br />
         $object = New-Object PSObject<br />
         Add-Member -inputObject $object -memberType NoteProperty -name Giver -value $_.Name<br />
         Add-Member -inputObject $object -memberType NoteProperty -name Receiver -value $_.Value<br />
         $result += $object<br />
     }<br />
     $result<br />
 }</p>
<p> $none = &quot;NONE&quot;<br />
 $names = @{}<br />
 gc $file | % { $names.Add($_, $none) }<br />
 $namesToMatch = $names.Keys.Count<br />
 if ($namesToMatch -lt 2) {  throw &quot;Need at least two names to match&quot; }</p>
<p> while (($names.Keys | ? { $names.$_ -eq $none }).Length -gt 0)<br />
 {<br />
     $from = $names.Keys | ? { $names.$_ -eq $none } | Get-Random<br />
     $to = $names.Keys | ? { $_ -ne $from -and $names.Values -notcontains $_ } | Get-Random<br />
     #&quot;DEBUG: $from, $to&quot;<br />
     if ($from -ne $null -and $to -ne $null -and $from.split()[1] -ne $to.split()[1])<br />
     {<br />
         $names.$from = $to<br />
     }<br />
     else<br />
     {<br />
         $undoMatch = $names.Keys | ? { $names.Values -ne $none `<br />
             -and $from.split()[1] -ne $_.split()[1]} | Get-Random<br />
         #&quot;DEBUG: unset $undoMatch&quot;<br />
         if ($undoMatch -ne $null)<br />
         {<br />
             $names.$undoMatch = $none<br />
         }<br />
     }<br />
     $percentComplete = 100 * ($names.Values | ? { $names.$_ -ne $none }).Length / $namesToMatch<br />
     Write-Progress -activity &quot;Match in Progress&quot; -status &quot;% Complete:&quot; -percentcomplete $percentComplete<br />
 }<br />
 $results = ConvertTo-Array $names<br />
 $results | ft<br />
[/sourcecode]</p>
<p>It reads the contents of the file and writes each line to a hashtable, where all the receivers are $none (a special value I created which I used like $null).</p>
<p>As long as there are unmatched people, I go through an algorithm to select a random gift giver who doesn’t have a receiver ($from) and a receiver who doesn’t have a giver ($to). The split(” “)[1] yields a person’s surname.</p>
<p>I used a variant on the “Hill Climbing” algorithm mentioned on the site. If I run into a situation where there are no more matches, I take a random person who could have been a match and throw them back into the pool of candidates. In this way, the algorithm never gets stuck.</p>
<p>At the end, I call my <code>ConvertTo-Array</code> function to beautify the output. Without it, the hashtable columns are labeled “Name” and “Value”, and that didn’t satisfy me. (I couldn’t get <code>Format-Table</code> to help.)</p>
<p>I added a progress bar to see how often this part of the code is invoked, and it gets called once or twice per run on average. However, the script itself has decent performance. It takes a second or so to match 40 names.</p>
<p>Please let me know what you think or ask questions. I’m happy to go into more detail.</p>

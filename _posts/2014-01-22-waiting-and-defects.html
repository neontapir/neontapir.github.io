---
layout: post
title: 'Lean Wastes and Software Delivery: Waiting and Defects'
date: 2014-01-22 18:41:51.000000000 -07:00
categories:
- process
- professional
tags:
- bottlenecks
- defects
- lean
- waiting
- waste
status: publish
type: post
published: true
meta:
  _publicize_twitter_user: "@ChuckDurfee"
  _yoast_wpseo_linkdex: '81'
  _edit_last: '5'
  _yoast_wpseo_focuskw: waiting
  _wpas_done_all: '1'
  _jetpack_related_posts_cache: a:1:{s:32:"8f6677c9d6b0f903e98ad32ec61f8deb";a:2:{s:7:"expires";i:1438144549;s:7:"payload";a:3:{i:0;a:1:{s:2:"id";i:1302;}i:1;a:1:{s:2:"id";i:1309;}i:2;a:1:{s:2:"id";i:1319;}}}}
author:
  login: Chuck
  email: chuck@neontapir.com
  display_name: Chuck
  first_name: Chuck
  last_name: Durfee
excerpt: !ruby/object:Hpricot::Doc
  options: {}
---
<div style="float: right; padding: 1em;"><a href="http://neontapir.com/wp/wp-content/uploads/2014/01/waiting.jpg"><img class="alignright size-medium wp-image-1292" alt="waiting" src="assets/waiting-198x300.jpg" width="198" height="300" /></a></div>
<p>Lean thinking comes from innovation in statistical process control. The idea is that honing techniques leads to measurably better results. Lean identifies eight "wastes", activities that subtract value from a process. They are:</p>
<ul>
<li>wasted talent</li>
<li>wasted inventory</li>
<li>wasted motion of people</li>
<li>wasted time (waiting)</li>
<li>wasted transportation of goods</li>
<li>defects</li>
<li>overproduction</li>
<li>overprocessing</li>
</ul>
<p>From the perspective of a software delivery project, some of these<br />
wastes don’t seem to apply. In this series of posts let’s focus on each<br />
in turn, starting with waiting and defects.</p>
<h2>Waiting and Defects</h2>
<blockquote><p>I hate waiting.</p>
<p>— Inigo Montoya, The Princess Bride</p></blockquote>
<p>When people think of lean processes, the waste of <strong>waiting</strong> is usually<br />
what they have in mind. In software delivery processes, it can manifest<br />
in a number of forms. In software delivery, it turns out that techniques<br />
that reduce waiting can also reduce <strong>defects</strong>. Defects occur when<br />
software doesn’t behave as intended.</p>
<p>When a delivery team member joins the team, inefficiencies in the<br />
onboarding process can introduce waste. If they are also joining the<br />
firm, the costs steepen. Every moment that the new person spends not<br />
adding value to the product is waste from this perspective. Thus, it’s<br />
important for the new person to be integrated into the team as quickly<br />
as possible. I recommend paired programming to minimize this kind of<br />
waste. Shadow a person who’s role you’ll be filling. See what they do<br />
and don’t do, and learn the new codebase like you would a foreign<br />
language, through immersion.</p>
<p>Okay, so all of the team is onboard. The next step is to look at your<br />
product delivery process for bottlenecks. In a lean process context, a<br />
bottleneck is a part of the process where flow is constricted. While<br />
there may be a number of inefficiencies in a system, the most severe<br />
bottleneck will constrict the entire system. Troubleshooting bottlenecks<br />
is beyond the scope of this post, but one of my favorite guides to the<br />
process is the <a href="http://www.troubleshooters.com/tpromag/9803.htm">Universal Troubleshooter’s<br />
Guide</a>.</p>
<p>One of the many examples given is one of a bicycle, with the goal of<br />
improving your commute time of two hours. If you have a $75 coaster<br />
break bike, what keeps you from going faster — the bottleneck of the<br />
system — is having just one gear, which is poorly suited to hills.</p>
<p>For $150, you might get a mountain bike with multiple speeds that gives<br />
you a 20% faster commute. Having removed the first bottleneck, the next<br />
limitation is wind buffeting from an inferior riding posture. A road<br />
bike for $300 can solve that bottleneck, which offers specialized tires<br />
and a better riding posture, yielding a 17% commute time improvement.</p>
<p>However, there is a point of diminishing returns. The next step up would<br />
be a mid-grade road bike, which overcomes the limitations of the<br />
entry-level components, but it only offers a 5% improvement for double<br />
the cost at \$600. Other approaches like training or riding clothes<br />
would likely yield better results, which implies that at this point bike<br />
components aren’t the bottleneck.</p>
<p>With the bike example in mind, think about your software delivery<br />
process. From idea to requirements to design to implementation to<br />
testing to customer validation, where is the point that work tends to<br />
pile up? That point is likely to be the bottleneck. Lean process has a<br />
lot of good guidance on finding and removing bottlenecks, and it’s worth<br />
exploring even if you are using another agile methodology like scrum.<br />
Once you identify the bottleneck, there are techniques that can increase<br />
delivery speed at each stage:</p>
<table width="80%" frame="border" cellspacing="0" cellpadding="4">
<colgroup>
<col width="25%" />
<col width="75%" /></colgroup>
<thead>
<tr>
<th align="left" valign="top">Stage</th>
<th align="left" valign="top">Techniques</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top">
<p class="table">Idea to requirements</p>
</td>
<td align="left" valign="top">
<p class="table">Backlog grooming, domain-specific language (DSL), working agreements</p>
</td>
</tr>
<tr>
<td align="left" valign="top">
<p class="table">Requirements to design</p>
</td>
<td align="left" valign="top">
<p class="table">Prototyping, behavior-driven development (BDD), domain-driven design (DDD), unified modeling language (UML)</p>
</td>
</tr>
<tr>
<td align="left" valign="top">
<p class="table">Design to implementation</p>
</td>
<td align="left" valign="top">
<p class="table">Paired programming, continuous integration (CI), version-control system (VCS), test-first development (TDD)</p>
</td>
</tr>
<tr>
<td align="left" valign="top">
<p class="table">Implementation to delivery</p>
</td>
<td align="left" valign="top">
<p class="table">Automated acceptance testing, continuous deployment</p>
</td>
</tr>
</tbody>
</table>
<p>Notes: "Paired programming" is usually "pair programming" though I prefer "paired" because paired is a better adjectival descriptive of the activity than the verb "to pair". Similarly, TDD is usually "test-driven" but I prefer "test-first" because it more accurately sums up the philosophy of writing software guided by tests.</p>
<p><strong>Backlog grooming</strong> allows a product owner to engage a delivery team<br />
during story creation. These sessions offer teams a separation between<br />
communicating what the work is and deciding how to accomplish the work.<br />
Product owner can use the feedback on the newly-drafted stories to<br />
refine the stories, address the team’s questions and concerns, and use<br />
the team’s rough size estimates for release planning. Without backlog<br />
grooming, these "what" and "how" discussions both happen during<br />
iteration planning. I’ve found mixing the two discussions to be<br />
inefficient, because the variations in design and other aspects of the<br />
"how" are much larger if team members have different concepts of what’s<br />
being requested, and thus it takes longer to reach concensus.</p>
<p>Product owners and teams need a common trade language to bridge the gap<br />
between business requirements and technical requirements, and the best<br />
tool I’ve found for this is <strong>behavior-driven development</strong> or BDD. I<br />
prefer Cucumber as a framework, which forms a <strong>domain-specific<br />
language</strong> (DSL) or jargon for communicating requirements. Each feature<br />
and requirement are expressed in a certain format, which programmers can<br />
easily map to automated tests.</p>
<p>This idea of a DSL can be extended further to the problem domain, which<br />
brings up a number of concepts from <strong>domain-driven design</strong>, especially<br />
<em>ubiquitous language</em>. It’s very helpful if the business experts use<br />
terms the same way as the technical staff. It helps them both understand<br />
the problem space better. While it’s true that domain-driven design<br />
includes a number of tactical technical patterns, it also contains a<br />
number of strategic approaches for modeling domains that are of use to<br />
both business experts and delivery technicians.</p>
<p>The same holds true of technical diagrams. Since there are so many ways<br />
to visually communicate information, it can take time and effort to<br />
communicate how symbols are being used. Use of a common standard like<br />
the <strong>unified modeling language</strong> (UML) can alleviate this. For people<br />
who know the language, the individual symbols fade into the background<br />
and the focus because the message they intend to convey.</p>
<p>Just as a ubiquitous language and UML can help smooth communications,<br />
<strong>working agreements</strong> can help teams make decisions ahead of time.<br />
Common working agreements include a <strong>definition of done</strong> and a<br />
<strong>definition of ready</strong>. For example, as part of a definition of done,<br />
if all team members accept that a story isn’t ready to code until the<br />
<strong>acceptance criteria</strong> are defined — the things the product owner<br />
expects to be true when the story is ready for acceptance — then that’s<br />
one decision that doesn’t need to be made with every story. The<br />
conversation shifts from "hey, do we need acceptance criteria on this<br />
one?" to "how will we show you that we’re done with this story".<br />
Rehashing decisions over and over is a form of waste. Teams should only<br />
revisit these agreements once in a great while or when something<br />
changes.</p>
<p><strong>Prototypes</strong> are a 21st Century version of the saying, "a picture is<br />
worth a thousand words". When exploring new applications, new technical<br />
infrastructure or new approaches, prototypes can be very useful. They<br />
offer an environment for engineers to learn how best to leverage<br />
technologies to achieve a goal. Prototypes can also be useful to<br />
business experts, who can get some tactile feedback on their proposed<br />
workflows. I know teams that use prototypes even for established<br />
applications to verify their understanding of the requirements.</p>
<p>When working in a language that is as abstract as a computer programming<br />
language, even the most expressive code can be challenging. <strong>Paired<br />
programming</strong> is the most direct way for one delivery team member to<br />
communicate low-level technical implementation details with another one.<br />
Although it can be slower to implement a feature using paired<br />
programming than with a solitary programmer, studies have shown that the<br />
code produced by a pair contains fewer defects and that the majority of<br />
defects are found during code reviews. For a pair of programmers, code<br />
reviews occur naturally and continuously. Because mistakes are least<br />
expensive to fix while the code is being written, the overall time to<br />
produce quality code is reduced by paired programming.</p>
<p>Sitting next to another developer isn’t a luxury everyone can enjoy. I<br />
know a number of developers who pair remotely using a virtual network<br />
computing (VNC) tool like WinVNC and a telephone or get a second opinion<br />
with a screen-sharing tool like join.me or Skype. Many developers don’t<br />
see it paired programming as a luxury, but as a burden. For those<br />
uncomfortable with the concept, a weaker alternative that provides many<br />
of the benefits is an interactive code review in a conference room or<br />
via software as above. For distributed teams, or teams in a<br />
meeting-heavy work environment, a source control tool like Git with<br />
support for pull requests can provide a forum for asynchronous code<br />
reviews.</p>
<p><strong>Continuous integration</strong> (CI) describes a practical approach of<br />
coordinating the work of multiple developers through the use of a common<br />
code location. It’s advantageous when that code location can track<br />
changes, which is why most developers make use of a <strong>version control<br />
system</strong> (VCS) like Subversion or Git. Originally made to help coders<br />
collaborate, use of VCS has expanded to <a href="http://web.archive.org/web/20131113121113/http://teach.github.com:80/articles/book-authoring-using-git-and-github/">book authors</a> and even<br />
<a href="https://blog.abevoelker.com/gitlaw-github-for-laws-and-legal-documents-a-tourniquet-for-american-liberty/">lawmakers</a>.</p>
<p>While a VCS can help contributors understand the evolution of a work<br />
product, it doesn’t include the ability to know whether the work product<br />
changes are productive. A CI tool like Jenkins or TeamCity automates the<br />
process of watching for changes and taking action, usually building the<br />
software and running automated tests. However, a CI server can be used<br />
for other tasks, like compiling code quality reports and building<br />
documentation as well.</p>
<p>One of the more popular uses is for <strong>continuous deployment</strong>, in which<br />
build artifacts that pass automated tests are automatically deployed to<br />
a test environment for manual inspection. Or they set up deployment at<br />
the push of a button, so that long-running tests won’t be disturbed by<br />
an untimely deployment. And, in a world where it’s easy to deploy<br />
changes or one where there’s a ready failover environment, companies can<br />
simply automatically deploy to production, knowing that they can easily<br />
revert if need be.</p>
<h3>Testing and Defects Reduction</h3>
<p>Testing does not improve speed to market, a key reason why delivery<br />
teams sometimes sacrifice testing. In most cases, though, testing is an<br />
important discipline for agile teams, because quality code will improve<br />
chances for longevity in the market. Here, we are talking about two<br />
primary kinds of testing: unit testing and automated acceptance testing.<br />
Both kinds of testing are about delivering the right thing to customer,<br />
not about delivering it faster.</p>
<p><strong>Test-first development</strong> is a tactical software development approach<br />
that ensures the programmer is the first user of the code being written.<br />
Each unit of code is exercised by I find that it quickly exposes<br />
potential design issues early, especially when it comes to consuming<br />
objects.</p>
<p>In writing these "unit" tests, I sometimes find myself writing<br />
boilerplate code or having to always use certain objects in conjunction,<br />
both of which can indicate beneficial refactoring. I sometimes find that<br />
I’m contemplating using an object in a new or different way, which can<br />
indicate a design flaw. I let my intuition be my guide — there is a<br />
difference between not writing tests because they are uninteresting<br />
(property getters and setters come to mind) and not writing tests<br />
because they are hard to orchestrate. I aim for 80% code coverage by<br />
tests, which gives me the benefits of TDD without imposing a dogmatic<br />
requirement to write uninteresting tests.</p>
<p><strong>Acceptance testing</strong> is closely related to unit tests, but for many,<br />
it’s a separate discipline. Not only do developers want to know that<br />
their new code is working correctly, they want to make sure it<br />
integrates with existing code or systems. These tests have a different<br />
audience, so they should be considered separately. Whole books have been<br />
written on this subject, please see them if you want strategies for<br />
agile testing, but it’s worth noting that troubles found during<br />
deployment or integration are still less expensive to fix than after<br />
shipment to the customer. Accordingly, it’s worth some effort to reduce<br />
defect escape rates with acceptance testing. For people who practice<br />
BDD, their Cucumber specifications can easily be implemented as<br />
acceptance tests.</p>
<p>While tools like FitNesse and Cucumber can help with acceptance testing,<br />
a CI tool can be used to run them automatically. This allows software<br />
development teams to develop a "car dashboard" of their code health,<br />
letting them know whether it’s safe to proceed or time to pull into a<br />
service station. Many teams create working agreements for how to handle<br />
failing builds or broken automated tests.</p>
<p>Sometimes defects occur because a piece of software is working but is<br />
hard to use. <strong>User experience</strong> can help alleviate common data entry<br />
mistakes like clicking on the wrong button when two are placed too close<br />
together, use of confusing labels, obscured functionality hidden in<br />
configuration menus and the like.</p>
<p>Next installment, we'll examine wasted talent.</p>

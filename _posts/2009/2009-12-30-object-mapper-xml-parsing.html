---
layout: post
comments: true
title: 'Object Mapper: XML Parsing'
date: 2009-12-30 16:55:55.000000000 -07:00
categories:
- professional
tags:
- array
- C#
- Command
- composite
- converter
- decorator
- design patterns
- element
- injector
- object
- object mapper
- parser
- parsing
- schema
- setter
- transformation
- XML
- XmlReader
- XSD
status: publish
type: post
published: true
meta:
  _edit_last: '1'
  delicious: a:3:{s:5:"count";s:1:"0";s:9:"post_tags";s:0:"";s:4:"time";s:10:"1268952164";}
  reddit: a:2:{s:5:"count";s:1:"0";s:4:"time";s:10:"1268952165";}
  _jetpack_related_posts_cache: a:1:{s:32:"8f6677c9d6b0f903e98ad32ec61f8deb";a:2:{s:7:"expires";i:1435109808;s:7:"payload";a:3:{i:0;a:1:{s:2:"id";i:401;}i:1;a:1:{s:2:"id";i:411;}i:2;a:1:{s:2:"id";i:443;}}}}
author:
  login: Chuck
  email: neontapir@gmail.com
  display_name: Chuck
  first_name: Chuck
  last_name: Durfee
excerpt: !ruby/object:Hpricot::Doc
  options: {}
---
<p>Recently, I've described <a href="http://neontapir.com/wp/2009/12/the-object-mapper-domain-model/">the object mapper's domain model</a> and illustrated that it's still evolving by discussing the "<a href="http://neontapir.wordpress.com/2009/12/29/object-mapper-generation-gap/">generation gap</a>". In this post, I talk about the components of the object mapper.</p>
<p>There are two main components to the object mapper. Since the mapper is configured via XML, clearly I need something to read in the XML and initialize the domain model. Because I'm constrained to C# 2.0, I used an XmlReader. To handle malformed mapping XML documents, I wrote an XSD schema and validate incoming XML before parsing.</p>
<p>Each node triggers the creation of a domain object. Each Source and Target is implemented with the <a href="http://en.wikipedia.org/wiki/Composite_pattern">Composite pattern</a> as an Element. Sources are comprised of Targets, and Targets are comprised of leaf elements like property mappings.</p>
<p>Each component of the Element Composite exposes an Execute method that calls a <a href="http://en.wikipedia.org/wiki/Command_pattern">Command</a>. There are two sets of commands: one working on objects, the other on elements (properties or fields). For example, there is an ObjectSetter, that simply sets the target to the source. Correspondingly, an ElementSetter sets the target property value to the source property's value. </p>
<p>Other types of Commands include an ObjectConverter, which invokes the conversion Function on the source and sets the target object equal to the result, and an ElementInjector, which sets a target element equal to a value specified in the mapping XML.</p>
<p>Array transformations are handled by way of a <a href="http://en.wikipedia.org/wiki/Decorator_pattern">Decorator</a>, which handles the invokation of the decorated Command on each element in the array.</p>
<p>Next post, I'll talk about how I made some progress on bridging that generation gap.</p>

---
layout: post
title: 'Object Mapper: Bridging the Gap'
date: 2009-12-31 15:35:48.000000000 -07:00
categories:
- professional
tags:
- Adapter
- array
- C#
- design patterns
- ElementInfo
- Factory
- field
- FieldInfo
- IAccessor
- object mapper
- property
- PropertyInfo
- refactoring
- Reflection
status: publish
type: post
published: true
meta:
  _edit_last: '1'
  delicious: a:3:{s:5:"count";s:1:"0";s:9:"post_tags";s:0:"";s:4:"time";s:10:"1268952163";}
  reddit: a:2:{s:5:"count";s:1:"0";s:4:"time";s:10:"1268952168";}
  _jetpack_related_posts_cache: a:1:{s:32:"8f6677c9d6b0f903e98ad32ec61f8deb";a:2:{s:7:"expires";i:1428321967;s:7:"payload";a:3:{i:0;a:1:{s:2:"id";i:443;}i:1;a:1:{s:2:"id";i:336;}i:2;a:1:{s:2:"id";i:242;}}}}
author:
  login: Chuck
  email: chuck@neontapir.com
  display_name: Chuck
  first_name: Chuck
  last_name: Durfee
excerpt: !ruby/object:Hpricot::Doc
  options: {}
---
<p>Recently, I talked about the <a href="http://neontapir.wordpress.com/2009/12/29/object-mapper-generation-gap/">generation gap</a> I faced when considering elements at different levels of the hierarchy. I have a partial solution.</p>
<p>Recall I have the following hierarchy of objects:</p>
<p>Person { Name : string }<br />
Parent { Children : Person[] } is-a Person<br />
Grandparent { Grandchildren : Person[] } is-a Parent</p>
<p>So, I created the following test classes:</p>
<div style="font-family:Courier New;font-size:10pt;color:black;background:white;">
<p style="margin:0;"><span style="color:blue;">public</span> <span style="color:blue;">class</span> <span style="color:#2b91af;">Person</span></p>
<p style="margin:0;">{</p>
<p style="margin:0;">&nbsp;&nbsp;&nbsp; <span style="color:blue;">public</span> <span style="color:blue;">string</span> _name;</p>
<p style="margin:0;">&nbsp;</p>
<p style="margin:0;">&nbsp;&nbsp;&nbsp; <span style="color:blue;">public</span> <span style="color:blue;">string</span> Name</p>
<p style="margin:0;">&nbsp;&nbsp;&nbsp; {</p>
<p style="margin:0;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color:blue;">get</span> { <span style="color:blue;">return</span> _name; }</p>
<p style="margin:0;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color:blue;">set</span> { _name = <span style="color:blue;">value</span>; }</p>
<p style="margin:0;">&nbsp;&nbsp;&nbsp; }</p>
<p style="margin:0;">&nbsp;</p>
<p style="margin:0;">&nbsp;&nbsp;&nbsp; <span style="color:blue;">public</span> <span style="color:#2b91af;">Person</span>[] Siblings;</p>
<p style="margin:0;">&nbsp;&nbsp;&nbsp; <span style="color:blue;">public</span> <span style="color:#2b91af;">Person</span>[] Parents;</p>
<p style="margin:0;">}</p>
<p style="margin:0;">&nbsp;</p>
<p style="margin:0;"><span style="color:blue;">public</span> <span style="color:blue;">class</span> <span style="color:#2b91af;">Parent</span> : <span style="color:#2b91af;">Person</span></p>
<p style="margin:0;">{</p>
<p style="margin:0;">&nbsp;&nbsp;&nbsp; <span style="color:blue;">public</span> <span style="color:#2b91af;">Person</span> _firstborn;</p>
<p style="margin:0;">&nbsp;</p>
<p style="margin:0;">&nbsp;&nbsp;&nbsp; <span style="color:blue;">public</span> <span style="color:blue;">string</span> FirstbornsName;</p>
<p style="margin:0;">&nbsp;</p>
<p style="margin:0;">&nbsp;&nbsp;&nbsp; <span style="color:blue;">public</span> <span style="color:#2b91af;">Person</span> Firstborn</p>
<p style="margin:0;">&nbsp;&nbsp;&nbsp; {</p>
<p style="margin:0;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color:blue;">get</span> { <span style="color:blue;">return</span> _firstborn; }</p>
<p style="margin:0;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color:blue;">set</span> { _firstborn = <span style="color:blue;">value</span>; }</p>
<p style="margin:0;">&nbsp;&nbsp;&nbsp; }</p>
<p style="margin:0;">&nbsp;</p>
<p style="margin:0;">&nbsp;&nbsp;&nbsp; <span style="color:blue;">public</span> <span style="color:#2b91af;">Person</span>[] _children;</p>
<p style="margin:0;">&nbsp;&nbsp;&nbsp; <span style="color:blue;">public</span> <span style="color:#2b91af;">Person</span>[] Children</p>
<p style="margin:0;">&nbsp;&nbsp;&nbsp; {</p>
<p style="margin:0;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color:blue;">get</span> { <span style="color:blue;">return</span> _children; }</p>
<p style="margin:0;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color:blue;">set</span> { _children = <span style="color:blue;">value</span>; }</p>
<p style="margin:0;">&nbsp;&nbsp;&nbsp; }</p>
<p style="margin:0;">&nbsp;</p>
<p style="margin:0;">&nbsp;</p>
<p style="margin:0;">&nbsp;&nbsp;&nbsp; <span style="color:blue;">public</span> <span style="color:blue;">object</span> <span style="color:blue;">this</span>[<span style="color:blue;">int</span> index]</p>
<p style="margin:0;">&nbsp;&nbsp;&nbsp; {</p>
<p style="margin:0;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color:blue;">get</span> { <span style="color:blue;">return</span> _children[index]; }</p>
<p style="margin:0;">&nbsp;&nbsp;&nbsp; }</p>
<p style="margin:0;">}</p>
<p style="margin:0;">&nbsp;</p>
<p style="margin:0;"><span style="color:blue;">public</span> <span style="color:blue;">class</span> <span style="color:#2b91af;">Grandparent</span> : <span style="color:#2b91af;">Parent</span></p>
<p style="margin:0;">{</p>
<p style="margin:0;">&nbsp;&nbsp;&nbsp; <span style="color:blue;">public</span> <span style="color:#2b91af;">Person</span>[] _grandchildren;</p>
<p style="margin:0;">&nbsp;</p>
<p style="margin:0;">&nbsp;&nbsp;&nbsp; <span style="color:blue;">public</span> <span style="color:#2b91af;">Person</span>[] Grandchildren</p>
<p style="margin:0;">&nbsp;&nbsp;&nbsp; {</p>
<p style="margin:0;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color:blue;">get</span> { <span style="color:blue;">return</span> _grandchildren; }</p>
<p style="margin:0;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color:blue;">set</span> { _grandchildren = <span style="color:blue;">value</span>; }</p>
<p style="margin:0;">&nbsp;&nbsp;&nbsp; }</p>
<p style="margin:0;">}</p>
</div>
<p>Obviously, these test classes will never form the basis of a top-notch genealogy program, but they are adequate to serve my purpose.</p>
<p>And, with the changes I'm about to describe, I'm able to write a passing test like this:</p>
<div style="font-family:Courier New;font-size:10pt;color:black;background:white;">
<p style="margin:0;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; [Test]</p>
<p style="margin:0;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color:blue;">public</span> <span style="color:blue;">void</span> Grandchildren_test()</p>
<p style="margin:0;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; {</p>
<p style="margin:0;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color:blue;">string</span> xmlToParse =</p>
<p style="margin:0;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color:blue;">string</span>.Format(</p>
<p style="margin:0;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color:#a31515;">@"&lt;?xml version=""1.0"" encoding=""utf-8""?&gt;</span></p>
<p style="margin:0;"><span style="color:#a31515;">&lt;Maps&gt;&nbsp;&nbsp;&nbsp; </span></p>
<p style="margin:0;"><span style="color:#a31515;">&nbsp;&nbsp;&nbsp; &lt;Source ID=""source1"" Type=""{2}""&gt;</span></p>
<p style="margin:0;"><span style="color:#a31515;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &lt;Target ID=""target1"" Type=""{1}""&gt;</span></p>
<p style="margin:0;"><span style="color:#a31515;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &lt;Element Source=""Children"" Target=""Siblings"" /&gt;</span></p>
<p style="margin:0;"><span style="color:#a31515;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &lt;Element Source=""Grandchildren[0]"" Target=""Firstborn"" /&gt;</span></p>
<p style="margin:0;"><span style="color:#a31515;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &lt;Element Source=""Grandchildren[0].Name"" Target=""FirstbornsName"" /&gt;</span></p>
<p style="margin:0;"><span style="color:#a31515;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &lt;!-- &lt;Element Source=""Name"" Target=""Parents[0].Name"" /&gt; --&gt;</span></p>
<p style="margin:0;"><span style="color:#a31515;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &lt;/Target&gt;</span></p>
<p style="margin:0;"><span style="color:#a31515;">&nbsp;&nbsp;&nbsp; &lt;/Source&gt;</span></p>
<p style="margin:0;"><span style="color:#a31515;">&lt;/Maps&gt;</span></p>
<p style="margin:0;"><span style="color:#a31515;">"</span>, <span style="color:blue;">typeof</span>(Person).FullName, <span style="color:blue;">typeof</span>(Parent).FullName, <span style="color:blue;">typeof</span>(Grandparent).FullName);</p>
<p style="margin:0;">&nbsp;</p>
<p style="margin:0;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color:#2b91af;">MappingDocumentParsingEngine</span> parser = <span style="color:blue;">new</span> <span style="color:#2b91af;">MappingDocumentParsingEngine</span>();</p>
<p style="margin:0;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color:#2b91af;">List</span>&lt;<span style="color:#2b91af;">ElementBase</span>&gt; elements = <span style="color:blue;">new</span> <span style="color:#2b91af;">List</span>&lt;<span style="color:#2b91af;">ElementBase</span>&gt;(parser.Parse(xmlToParse));</p>
<p style="margin:0;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="color:#2b91af;">ObjectConversionEngine</span> converter = <span style="color:blue;">new</span> <span style="color:#2b91af;">ObjectConversionEngine</span>(elements.ToArray());</p>
<p style="margin:0;">&nbsp;</p>
<p style="margin:0;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Grandparent ellis = <span style="color:blue;">new</span> Grandparent();</p>
<p style="margin:0;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ellis._name = <span style="color:#a31515;">"Ellis"</span>;</p>
<p style="margin:0;">&nbsp;</p>
<p style="margin:0;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Person andy = <span style="color:blue;">new</span> Person();</p>
<p style="margin:0;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; andy._name = <span style="color:#a31515;">"Andy"</span>;</p>
<p style="margin:0;">&nbsp;</p>
<p style="margin:0;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Person steve = <span style="color:blue;">new</span> Person();</p>
<p style="margin:0;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; steve._name = <span style="color:#a31515;">"Steve"</span>;</p>
<p style="margin:0;">&nbsp;</p>
<p style="margin:0;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Parent charles = <span style="color:blue;">new</span> Parent();</p>
<p style="margin:0;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; charles._name = <span style="color:#a31515;">"Chuck"</span>;</p>
<p style="margin:0;">&nbsp;</p>
<p style="margin:0;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; charles._children = <span style="color:blue;">new</span> Person[] { andy };</p>
<p style="margin:0;">&nbsp;</p>
<p style="margin:0;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ellis._children = <span style="color:blue;">new</span> Person[] { steve, charles };</p>
<p style="margin:0;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ellis._grandchildren = <span style="color:blue;">new</span> Person[] { andy };</p>
<p style="margin:0;">&nbsp;</p>
<p style="margin:0;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Parent actual = (Parent)converter.Convert(ellis);</p>
<p style="margin:0;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Assert.AreEqual(<span style="color:#a31515;">"Andy"</span>, actual.Firstborn.Name);</p>
<p style="margin:0;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Assert.Contains(actual.Siblings, steve);</p>
<p style="margin:0;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Assert.AreEqual(<span style="color:#a31515;">"Andy"</span>, actual.FirstbornsName);</p>
<p style="margin:0;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Assert.AreEqual(<span style="color:#a31515;">"Ellis"</span>, actual.Parents[0].Name);</p>
<p style="margin:0;">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; }</p>
</div>
<p>And, yes, I used some of my own family names for testing. And I crammed multiple tests into one for brevity.</p>
<p>The part of the design that made this painful before was my ElementInfo class. In the Reflection library, the PropertyInfo and FieldInfo classes are very similar, but their method signatures are slightly different to accommodate indexed properties. I wanted to avoid making this distinction throughout my code, so I created an Adapter class I called ElementInfo to provide the rest of my code a unified interface, exposing a GetValue(), SetValue(), and Type.  </p>
<p>However, it turns out my ElementInfo class had two responsibilities:</p>
<ol>
<li>Make a distinction between a property and a field
</li>
<li>Act as an accessor for a type (that is, to get and set values)
</li>
</ol>
<p>As a result, it was hard to extend. So, I decided to separate the ElementInfo class into two. During this exercise, it dawned on me that properties and fields are collectively called accessors, which lit the way for me to redesign this part of the domain model. </p>
<p>It was the ElementInfo constructor that was determining whether an accessor was a property or a field, so its logic got moved to an AccessorFactory. I re-ran my test suite, and everything passed (it was all green).</p>
<p>Once I did that, ElementInfo just had that decision logic in its own methods. Remembering that my goal was to extend this class to handle more types of accessors, I extracted an IAccessor interface and made ElementInfo implement it. (I use ReSharper, so refactorings like this are largely automated.) I then used the "Use Base Type Where Possible..." refactoring, so that as much as possible, I wasn't using my old ElementInfo class. </p>
<p>I then created Property and Field classes that implemented IAccessor, and reprogrammed the AccessorFactory to return Property and Field objects instead of ElementInfo objects. Re-ran the tests; all were green except the indexed property tests. So I deleted the ElementInfo class.</p>
<p>Now, I was in the position to create some new IAccessor implementations. The first I did was IndexedProperty, which you may recall that I had put into ElementInfo from last time. As I hoped, the only thing I needed to do to integrate it was add it to the Create() method on the AccessorFactory. Ran the tests; test suite still shows all green.</p>
<p>The first new implementation I needed was something I started out calling IndexableProperty, the idea being that it was a property whose type could be accessed with an indexer. However, it quickly became an ArrayProperty, because in my use case, the only examples of this are arrays. The analogous ArrayField followed shortly thereafter. With these in place, the Grandchildren[0] -&gt; Firstborn mapping works.</p>
<p>What about Grandchild[0].Name? The engine doesn't understand dot notation yet. So I created an AccessorComposite IAccessor that takes multiple accessors chained by dots. It splits the accessor string on the dots and calls the AccessorFactory on each fragment. Now the Grandchildren[0].Name -&gt; FirstbornsName mapping works.</p>
<p>I still have a challenge ahead. The commented-out mapping, Name -&gt; Parents[0].Name, still won't work. When the AccessorComposite tries to set the value of Parents[0].Name, it fails because Parents hasn't been initialized. I could create some code that would initialize the Parents array. If I did, the array of Parents would be { null }, and trying to get the value of null.Name doesn't compute. I would need to have the array of Parents equal to { new Person() }, and then try to set that new Person's name. For me, this is beyond the call of duty of an accessor representation!</p>
<p>I need to decide whether the user should explicitly populate Parents[0] before trying to set the name in the mapping, and if so how, or whether some other part of the engine should handle it. I'm leaning towards making it an explicit initialization, because having an array be null or empty might have meaning to the consumer of a converted object, and I don't want to prevent the ability to return those special values. </p>
<p>Transforming arrays is a nice segue into some of the challenges of having to infer type information, which will be discussed in the next post.</p>

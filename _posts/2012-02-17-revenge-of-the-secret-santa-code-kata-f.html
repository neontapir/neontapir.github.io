---
layout: post
title: Revenge of the Secret Santa Code Kata - F#
date: 2012-02-17 10:11:10.000000000 -07:00
categories:
- coding
- professional
tags:
- code exercise
- f-sharp
- F#
status: publish
type: post
published: true
meta:
  tumblr_agiletapir_permalink: http://agiletapir.tumblr.com/post/17391733734/revenge-of-the-secret-santa-code-kata-f
  tumblr_agiletapir_id: '17391733734'
  _wp_old_slug: '17391733734'
  _edit_last: '5'
  _syntaxhighlighter_encoded: '1'
  _jetpack_related_posts_cache: a:1:{s:32:"8f6677c9d6b0f903e98ad32ec61f8deb";a:2:{s:7:"expires";i:1436982853;s:7:"payload";a:3:{i:0;a:1:{s:2:"id";i:528;}i:1;a:1:{s:2:"id";i:700;}i:2;a:1:{s:2:"id";i:696;}}}}
author:
  login: Chuck
  email: chuck@neontapir.com
  display_name: Chuck
  first_name: Chuck
  last_name: Durfee
excerpt: !ruby/object:Hpricot::Doc
  options: {}
---
<p>Here’s another solution to the <a href="http://rubyquiz.com/quiz2.html">Secret Santa code kata</a>, this time a scouting mission into functional programming with F#.</p>
<p>To recap:</p>
<ul>
<li>My <a href="http://neontapir.com/wp/2012/01/secret-santa-code-kata-in-powershell/">first solution</a>, written in PowerShell, relied on selecting random pairs of people and using a “hill-climbing” algorithm to avoid getting stuck.</li>
<li>My <a href="http://neontapir.com/wp/2012/02/secret-santa-code-kata-redux-in-c/">second solution</a> I constrained to be deterministic — no randomness.</li>
</ul>
<p>This one was more about trying to write something meaningful in F# using a problem I’m by now familiar with. Take a look at the code:</p>
<p>[sourcecode language="fsharp" collapse="true"]<br />
open System<br />
open System.IO</p>
<p>// TODO: what's the accepted way to configure an F# program at runtime, App.config?<br />
let lines = File.ReadAllLines(@&amp;quot;names_santa.txt&amp;quot;) |&amp;amp;gt; List.ofArray</p>
<p>let surname (x : string) = (x.Split ' ').[1]</p>
<p>// TODO: how do I make this generic enough to use in both cases below?<br />
let lastItem (a : string[]) = a.[a.Length - 1]</p>
<p>let randomizer = new Random(DateTime.Now.Millisecond)</p>
<p>let swap (a: _[]) x y =<br />
    let tmp = a.[x]<br />
    a.[x] &amp;amp;lt;- a.[y]<br />
    a.[y] &amp;amp;lt;- tmp</p>
<p>// shuffle an array (in-place), borrowed from a code snippet site<br />
let shuffle a =<br />
    let len = Array.length a<br />
    Array.iteri (fun i _ -&amp;amp;gt; swap a i (randomizer.Next(i, len))) a</p>
<p>let linesArray = Array.ofList lines</p>
<p>// TODO: this &amp;quot;do-while&amp;quot; loop, I should be able to rewrite it as a recursive function, but how?<br />
shuffle linesArray<br />
while surname linesArray.[0] = surname linesArray.[(Array.length linesArray) - 1] do shuffle linesArray</p>
<p>let rec pairings = linesArray<br />
                    |&amp;amp;gt; Seq.windowed 2<br />
                    |&amp;amp;gt; Seq.choose (fun (x:string[]) -&amp;amp;gt;<br />
                                        match x with<br />
                                        | x when surname x.[0] &amp;amp;lt;&amp;amp;gt; surname x.[1] -&amp;amp;gt; Some(x)<br />
                                        | _ -&amp;amp;gt; None<br />
                                   ) </p>
<p>let pairingsList = List.ofSeq pairings</p>
<p>List.append pairingsList [[|pairingsList.[pairingsList.Length - 1].[1]; pairingsList.[0].[0]|]] |&amp;amp;gt;<br />
    Seq.iter (fun (x:string[]) -&amp;amp;gt; printfn &amp;quot;%s gives a gift to %s&amp;quot; x.[0] x.[1])</p>
<p>Console.WriteLine &amp;quot;Done, press Enter to exit&amp;quot;<br />
Console.ReadLine() |&amp;amp;gt; ignore<br />
[/sourcecode]</p>
<p>As you can see, I left myself a few to-do items. I boxed the effort at three hours, which is why I went ahead and borrowed the shuffle logic from the internet.</p>
<p>The first hour was learning to speak F# again, especially the method signatures. I played with F# when it was in beta, so I didn’t go into the kata stone cold. However, it took me a while to troubleshoot why my methods didn’t have the signature I expected.</p>
<p>I spent the most time writing the <code>pairings</code> function. Once I had the insight of using the match operator, the algorithm came together very quickly. I decided that I wasn’t happy with it being deterministic. I found that if I provided a file that was already in an appropriate order, <code>pairings</code> regurgitated the list. Dissatisfied, I went about trying to shuffle the array. Not being familiar with unit testing in F#, I used the F# Interactive console. I got frustrated with trying to implement the shuffle algorithm, so I decided to study a working copy.</p>
<p>The hard part came in integrating it with my code. I resorted to using a while loop, which I know from reading about functional programs means that I’m not thinking of the problem through. I believe I couldn’t convert this into a recursive function because <code>shuffle</code> returns a <code>unit</code> (that is, it does the work inline). If it returned an array, I bet I’ve have more luck. I’ll have to experiment further.</p>
<p>My attempts to rewrite the loop badly broke the program. I used comments as poor man’s source control, and I got lucky. I really should have check in the first working version into my local Subversion repository.</p>
<p>Some time passed. I managed to look at the do-while problem again, and after about 90 minutes, I solved both it and another issue that bugged me.</p>
<p>Here’s the second revision:<br />
[sourcecode language="fsharp" collapse="true"]<br />
open System<br />
open System.IO</p>
<p>let randomizer = new Random(DateTime.Now.Millisecond)</p>
<p>let surname (x : string) = (x.Split ' ').[1]<br />
let lastItem (a : 'a list) = a.[a.Length - 1]</p>
<p>let shuffle items =<br />
    let upperBound = (List.length items) * 100<br />
    let randomlyWeightedItems = List.map (fun item -&amp;amp;gt; item, randomizer.Next(0, upperBound)) items<br />
    let sortedByWeight = List.sortWith (fun (_, leftWeight) (_, rightWeight) -&amp;amp;gt; leftWeight - rightWeight) randomlyWeightedItems<br />
    List.map (fun (item, _) -&amp;amp;gt; item) sortedByWeight</p>
<p>let shuffleUntilEndsDiffer theList =<br />
    let rec loop a =<br />
        let shuffled = shuffle a<br />
        if surname shuffled.Head = surname (lastItem shuffled) then<br />
            loop shuffled<br />
    loop theList</p>
<p>// Main part of the program, need to find out how to separate code into files</p>
<p>let lines = List.ofArray (File.ReadAllLines(@&amp;quot;names_santa.txt&amp;quot;))</p>
<p>shuffleUntilEndsDiffer lines</p>
<p>let rec pairings = lines<br />
                    |&amp;amp;gt; Seq.windowed 2<br />
                    |&amp;amp;gt; Seq.choose (fun (x:string[]) -&amp;amp;gt;<br />
                                        match x with<br />
                                        | x when surname x.[0] &amp;amp;lt;&amp;amp;gt; surname x.[1] -&amp;amp;gt; Some(x)<br />
                                        | _ -&amp;amp;gt; None<br />
                                    )<br />
                    |&amp;amp;gt; List.ofSeq </p>
<p>let veryFirstPerson = pairings.Head.[0]<br />
let veryLastPerson = (lastItem pairings).[1] </p>
<p>List.append pairings [[|veryLastPerson; veryFirstPerson|]]<br />
    |&amp;amp;gt; Seq.iter (fun (x:string[]) -&amp;amp;gt; printfn &amp;quot;%s gives to %s&amp;quot; x.[0] x.[1])</p>
<p>Console.ReadLine()<br />
    |&amp;amp;gt; ignore<br />
[/sourcecode]</p>
<p>The do-while loop was solved by making the shuffling function return the shuffled contents instead of unit (void in C# parlance).</p>
<p>The second change was to get away from arrays. Arrays in F# are mutable, and I wanted to only use immutable data structures as much as possible.</p>
<p>The shuffler was the main barrier. Once I hit upon the idea to associate each person with external data, in this case a random weighting, the rest fell into place. You may also notice some language usage improvements, such as using <code>a.Head</code> instead of <code>a.[0]</code></p>
<p>Questions? Comments?</p>

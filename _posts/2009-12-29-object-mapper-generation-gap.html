---
layout: post
comments: true
title: 'Object Mapper: Generation Gap'
date: 2009-12-29 16:36:41.000000000 -07:00
categories:
- professional
tags:
- children
- ElementInfo
- generation
- grandparent
- indexed
- inheritance
- nested
- object mapper
- parent
- person
- polymorphism
- properties
status: publish
type: post
published: true
meta:
  _edit_last: '1'
  delicious: a:3:{s:5:"count";s:1:"0";s:9:"post_tags";s:0:"";s:4:"time";s:10:"1268952165";}
  reddit: a:2:{s:5:"count";s:1:"0";s:4:"time";s:10:"1268952170";}
  _jetpack_related_posts_cache: a:1:{s:32:"8f6677c9d6b0f903e98ad32ec61f8deb";a:2:{s:7:"expires";i:1437854914;s:7:"payload";a:3:{i:0;a:1:{s:2:"id";i:451;}i:1;a:1:{s:2:"id";i:401;}i:2;a:1:{s:2:"id";i:411;}}}}
author:
  login: Chuck
  email: chuck@neontapir.com
  display_name: Chuck
  first_name: Chuck
  last_name: Durfee
excerpt: !ruby/object:Hpricot::Doc
  options: {}
---
<p>In yesterday's post about the <a href="http://neontapir.com/wp/2009/12/the-object-mapper-domain-model/">domain model</a>, I described some of the use cases for the object mapper.</p>
<p>In trying to use it in a real-world situation today, my co-worker found another domain concept. </p>
<p>Let's say I have the following hierarchy of objects:</p>
<ul>
<li>Person { Name : string }
</li>
<li>Parent { Children : Person[] } is-a Person
</li>
<li>Grandparent { Grandchildren : Person[] } is-a Parent
</li>
</ul>
<p>Hopefully, that notation isn't too hard to read. By that, I mean to say that a Person has a Name, a Parent is a Person with an array of type Person called Children, and a Grandparent is a Parent with Grandchildren.</p>
<p>Let's further say that I want to use my Object Mapper to convert a Grandparent object into a Parent object. </p>
<p>To probe the problem, I created a new test class and started to write tests. I determined I'd need something like the following XML:</p>
<p>&lt;Source ID=&quot;source1&quot; Type=&quot;Grandparent&quot;&gt;<br />
  &lt;Target ID=&quot;target1&quot; Type=&quot;Parent&quot;&gt;<br />
    &lt;Element Source=&quot;<strong>[TBD]</strong>&quot; Target=&quot;Name&quot; /&gt;<br />
    &lt;Element Source=&quot;Grandchildren&quot; Target=&quot;Children&quot; /&gt;<br />
  &lt;/Target&gt;<br />
&lt;/Source&gt;</p>
<p>The fly in the ointment is what to put in the [TBD] section. I want the name of, say, the first child.</p>
<p>However, even with all of the elements I introduced yesterday, I have no way of asking for elements of different "generations", at different levels of the hierarchy. I have commands that can copy objects to objects and properties to properties, but not properties to objects or objects to properties.</p>
<p>Back to the TBD piece. It would be nice if it could read:</p>
<p>&lt;Element Source=&quot;Children[0].Name&quot; Target=&quot;Name&quot; /&gt;</p>
<p>Children[0] is a C#-ish way of saying the first item in the array of Children, and the number is called the index of the array.</p>
<p>Of course, the test is red (i.e., doesn't pass), because the Parent object doesn't have a property called "Children[0],Name". So far, so good.</p>
<p>This is really two problems in one. I decided to defer the issue of calling a property on a property (nested properties) by ignoring the Name part of the puzzle. So, I created an extra property on Parent called Firstborn, which I'll try to populate like this:</p>
<p>&lt;Element Source=&quot;Children[0]&quot; Target=&quot;Firstborn&quot; /&gt;</p>
<p>Failing test in hand, I applied myself to getting the test to pass. As I'll explain more in a future post, I have an Adapter class that allows me to treat fields and properties the same called ElementInfo. It's responsible for resolving properties, so I added support to the ElementInfo object to resolve indexed properties as well.</p>
<p>I re-ran my test. Still red.</p>
<p>After some debugging and head-scratching, I realized that what I really need is not support for indexed properties, but support for a property of a type that itself supports indexing, like Children which is an array. </p>
<p>To wit:</p>
<div style="font-family:Courier New;font-size:10pt;color:black;background:white;">
<p style="margin:0;"><span style="color:blue;">public</span> Person[] _children;</p>
<p style="margin:0;">&nbsp;</p>
<p style="margin:0;"><span style="color:green;">// what I want to be able to extract info from</span></p>
<p style="margin:0;"><span style="color:green;">// example: mom.Children[0]</span></p>
<p style="margin:0;"><span style="color:blue;">public</span> Person[] Children</p>
<p style="margin:0;">{</p>
<p style="margin:0;">&nbsp;&nbsp;&nbsp; <span style="color:blue;">get</span> { <span style="color:blue;">return</span> _children; }</p>
<p style="margin:0;">&nbsp;&nbsp;&nbsp; <span style="color:blue;">set</span> { _children = <span style="color:blue;">value</span>; }</p>
<p style="margin:0;">}</p>
<p style="margin:0;">&nbsp;</p>
<p style="margin:0;"><span style="color:green;">// what I ended up supporting, oops!</span></p>
<p style="margin:0;"><span style="color:green;">// example: mom[0]</span></p>
<p style="margin:0;"><span style="color:blue;">public</span> <span style="color:blue;">object</span> <span style="color:blue;">this</span>[<span style="color:blue;">int</span> index]</p>
<p style="margin:0;">{</p>
<p style="margin:0;">&nbsp;&nbsp;&nbsp; <span style="color:blue;">get</span> { <span style="color:blue;">return</span> _children[index]; }</p>
<p style="margin:0;">}</p>
</div>
<p>So, once more into the breach, dear friends! </p>
<p>I now return you to the scheduled posts in the series while I resolve this. The next post will talk some about the XML parser.</p>

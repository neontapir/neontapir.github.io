---
layout: post
title: BetaFish Part 3 - Scaredy Cat
date: 2012-03-22 06:46:46.000000000 -06:00
categories:
- coding
- professional
tags:
- code exercise
- f-sharp
- F#
- robocode
status: publish
type: post
published: true
meta:
  publicize_results: a:1:{s:7:"twitter";a:1:{i:17953864;a:2:{s:7:"user_id";s:11:"ChuckDurfee";s:7:"post_id";s:18:"182811854186352641";}}}
  _wpas_done_twitter: '1'
  jabber_published: '1332420716'
  _edit_last: '5'
  _syntaxhighlighter_encoded: '1'
  _jetpack_related_posts_cache: a:1:{s:32:"8f6677c9d6b0f903e98ad32ec61f8deb";a:2:{s:7:"expires";i:1434224345;s:7:"payload";a:3:{i:0;a:1:{s:2:"id";i:700;}i:1;a:1:{s:2:"id";i:696;}i:2;a:1:{s:2:"id";i:527;}}}}
author:
  login: Chuck
  email: chuck@neontapir.com
  display_name: Chuck
  first_name: Chuck
  last_name: Durfee
excerpt: !ruby/object:Hpricot::Doc
  options: {}
---
<p>This is article 3 in a series of posts in which I introduced the idea of building an F# robot for Robocode. The last installment showed an improved version of the robot that didn't bump into walls, but did quake at the sight of an enemy.</p>
<p>The twitching behavior I described in the last post is a result of receiving a number of events each turn. When the robot is hit, it tries to evade. However, when it sights an opponent, it turns to attack. Evade, attack, evade, attack... the robot gets stuck in a loop as long as the opponent is facing it and continues to fire. Poor BetaFish. Let's see if we can fix that:</p>
<p>[sourcecode language="fsharp" collapse="true"]<br />
namespace Neontapir<br />
open Robocode<br />
open System</p>
<p>type ActionType =<br />
    | EndGame<br />
    | Search<br />
    | Evade of float<br />
    | Attack of float<br />
    | AvoidWall</p>
<p>type BetaFish() =<br />
    inherit Robot()</p>
<p>    let random = Random(DateTime.Now.Millisecond)<br />
    let defaultFirepower = 3.0<br />
    let moveUnit = 20.0</p>
<p>     let randomTurn amount (robot:Robot) =<br />
        let direction = random.Next 2<br />
        match direction with<br />
            | 1 -&gt; robot.TurnLeft amount<br />
            | 0 -&gt; robot.TurnRight amount<br />
            | _ -&gt; failwith &quot;Unexpected direction value&quot;</p>
<p>     let shouldEvade enemyBearing =<br />
        match enemyBearing with<br />
        | bearing when Math.Abs(bearing : float) &lt; 20.0 -&gt; false<br />
        | _ -&gt; true</p>
<p>     let evade (robot:Robot) =<br />
        robot |&gt; randomTurn 90.0<br />
        robot.Ahead moveUnit</p>
<p>     let mutable lastEvent : ActionType = Search</p>
<p>     override robot.Run() =<br />
        try<br />
            while true do<br />
                match lastEvent with<br />
                | EndGame -&gt; ()<br />
                | AvoidWall -&gt;<br />
                    robot.Back moveUnit<br />
                    robot |&gt; randomTurn 30.0<br />
                    lastEvent &lt;- Search<br />
                | Evade attackerBearing -&gt;<br />
                    match attackerBearing with<br />
                    | bearing when not(shouldEvade bearing) -&gt;<br />
                        lastEvent &lt;- Attack defaultFirepower<br />
                    | _ -&gt;<br />
                        robot |&gt; evade<br />
                        lastEvent &lt;- Search<br />
                | Attack firepower -&gt;<br />
                    robot.Fire firepower<br />
                | Search<br />
                | _ -&gt;<br />
                    robot.Ahead moveUnit<br />
                    robot.TurnRight 40.0<br />
        with _ -&gt;<br />
            lastEvent &lt;- EndGame</p>
<p>    override robot.OnScannedRobot(event) =<br />
        match lastEvent with<br />
        | Attack _ -&gt; () // robot.Out.WriteLine &quot;Scanned robot&quot;<br />
        | _ -&gt;<br />
            robot.TurnRight event.Bearing<br />
            lastEvent &lt;- Attack defaultFirepower</p>
<p>    override robot.OnBulletHit(event) =<br />
        let newEvent =<br />
            match lastEvent with<br />
            | Attack strength -&gt;<br />
                Attack (Math.Min(strength + defaultFirepower, Rules.MAX_BULLET_POWER))<br />
            | _ -&gt; Attack defaultFirepower<br />
        lastEvent &lt;- newEvent</p>
<p>    override robot.OnBulletMissed(event) =<br />
        lastEvent &lt;- Search<br />
    override robot.OnHitByBullet(event) =<br />
        if (event.Bearing |&gt; shouldEvade) then lastEvent &lt;- Evade(event.Bearing)<br />
    override robot.OnHitWall(event) =<br />
        lastEvent &lt;- AvoidWall<br />
    override robot.OnDeath(event) =<br />
        lastEvent &lt;- EndGame<br />
    override robot.OnBattleEnded(event) =<br />
        lastEvent &lt;- EndGame<br />
[/sourcecode]</p>
<p>There are a few minor changes worth mentioning here:</p>
<ul>
<li>I renamed the <code>DoNothing</code> <code>ActionType</code> to <code>EndGame</code>for readability</li>
<li>I've encapsulated the <code>defaultFirepower</code> and <code>moveUnit</code>values for reuse</li>
<li>I'm doing more sophisticated pattern matching, like the nested match in <code>Run</code>'s <code>lastEvent</code> matching for the <code>Evade</code>type.</li>
<li>I dropped the type specifications on the handlers for Robocode events, since F#'s type inference engine can infer them</li>
</ul>
<p>To solve the twitching issue, I created a <code>shouldEvade</code> method that decides whether to try to evade fire. This version will stand and take it if it's facing an enemy. I found it odd that I had to specify that <code>bearing</code> was a <code>float</code> type, until I realized that <code>Math.Abs</code> has a number of overloads.</p>
<p>I changed the signature of <code>randomTurn</code> so I could use the piplining operator (<code>|&gt;</code>). This operator allowed to me write <code>robot |&gt; randomTurn 30.0</code>, which reads more natually to me than <code>randomTurn robot 30.0</code>. With pipelining, I'm able to say "with robot, do a random turn". My code less like Yoda sounds, pipeline it makes.</p>
<p>I wrapped the code in <code>Run</code> to solve another nagging issue. In previous versions, when the battle was over, BetaFish would often throw an exception or the battle simulator would have to terminate it. The <code>try ... with _ -&gt; lastEvent &lt;- EndGame</code> facility allowed me to catch the <code>DeathException</code> I often receive at the end of battle.</p>
<p>This BetaFish version, the one I'm submitting to the code kata, does far better than its predecessors. It almost beats the Fire sample robot. Fire often wins because it turns its gun and its body separately. If we get another go-round, I will try this strategy. I took a quick stab at it, but the first attempt did very poorly.</p>
<p>It still has problems, don't get me wrong. It runs like a scaredy cat if it gets fired upon a lot. It's performs poorly because it moves the whole tank body instead of just the gun or the radar. And it is easily defeated by the C# sample robot, that runs fast along the border and fires towards the middle. BetaFish can't get a lock on it fast enough.</p>
<p>Beyond the robot, there are certainly more F# features to explore. For example, I'm halfway through reading "Real World Functional Programming" by Petricek and Skeet, and a future chapter teases at a better way to handle event registration and waiting on events to fire. I can't wait!</p>
<p>I hope this article series has been of interest. Drop me a line if you found it interesting and would like to see more.</p>

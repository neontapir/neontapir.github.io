---
layout: post
title: Bowling Game kata using Node.js
date: 2014-01-08 09:15:52.000000000 -07:00
categories:
- coding
- professional
tags:
- kata
- node.js
- should
status: publish
type: post
published: true
meta:
  _wpas_skip_4335974: '1'
  _publicize_twitter_user: "@ChuckDurfee"
  _wpas_done_all: '1'
  _syntaxhighlighter_encoded: '1'
  _wpas_skip_5821802: '1'
  _edit_last: '5'
  _wpas_skip_28796: '1'
  _yoast_wpseo_linkdex: '79'
  _yoast_wpseo_focuskw: node
  _jetpack_related_posts_cache: a:1:{s:32:"8f6677c9d6b0f903e98ad32ec61f8deb";a:2:{s:7:"expires";i:1438203932;s:7:"payload";a:3:{i:0;a:1:{s:2:"id";i:1272;}i:1;a:1:{s:2:"id";i:860;}i:2;a:1:{s:2:"id";i:1302;}}}}
author:
  login: Chuck
  email: chuck@neontapir.com
  display_name: Chuck
  first_name: Chuck
  last_name: Durfee
excerpt: !ruby/object:Hpricot::Doc
  options: {}
---
<p><a href="http://neontapir.com/wp/wp-content/uploads/2014/01/bowling.jpg"><img class="alignright size-medium wp-image-1278" alt="bowling" src="assets/bowling-300x225.jpg" width="300" height="225" /></a></p>
<p>At work, my team is working on building commodity functionality for a SOA network of services. While learning more about SOA, I've become interested in <a href="http://nodejs.org‎">Node.js</a>, a JavaScript library that makes it easy and quick to build network applications.</p>
<p>When I'm first learning a language, one of the first projects I tackle is Bob Martin's <a href="http://butunclebob.com/ArticleS.UncleBob.TheBowlingGameKata">Bowling Game kata</a>. I've written about <a href="http://neontapir.com/wp/2012/08/code-katas/">code katas</a> before, suffice it to say I still think they are a valuable learning tool. When learning a new language, one of the first questions I want to answer is how to unit test my code, and this kata presents a fairly simple problem that's well-suited to test-first design.</p>
<p>So, I coded up a solution to the kata using node.js. There are plenty of examples on the web already, but I didn't use them directly. I fumbled around with node.js for a while, then I went looked to improve my knowledge of the language's facilities and constructs.</p>
<p>I used <a href="http://visionmedia.github.io/mocha/‎">Mocha</a> as my test framework. I discovered after a while that Mocha has a mode where you can have Mocha watch a folder for changes and execute tests using <code>mocha -w</code>. I find the instant feedback of continuous testing to be very valuable.</p>
<p>I started with <code>assert</code> for testing, but ended up choosing <a href="https://github.com/visionmedia/should.js/">should</a>, because I prefer BDD-style syntax when making assertions. Here's a representative sample, taken from early on in the kata:</p>
<p>[code lang="js"]<br />
game = require('..\\game.js');<br />
should = require(&quot;should&quot;);</p>
<p>var rollMany = function(times, pins) {<br />
    for (var i = 0; i &lt; times; i++) {<br />
        game.roll(pins);<br />
    }<br />
};</p>
<p>describe('When scoring a bowling game', function() {<br />
  beforeEach(function() {<br />
      game.reset();<br />
  });</p>
<p>  describe('all gutter balls', function() {<br />
      it('should score 0 for 20 gutter rolls', function() {<br />
          rollMany(20, 0);<br />
          game.score().should.equal(0);<br />
      });<br />
  });<br />
});<br />
[/code]</p>
<p>With assert, the assertion would look like:</p>
<p>[code lang="js"]<br />
assert.equal(game.score(), 0);<br />
[/code]</p>
<p>For simple assertions, assert is legible. However, for more complicated ones, I find that BDD-style syntax more naturally expresses what I'm verbalizing as I construct the test.</p>
<p>The code to actually perform score the game is:</p>
<p>[code lang="js" title="game.js"]<br />
module.exports.reset = function() {<br />
  rolls = new Array();<br />
  roll = 0;<br />
};</p>
<p>module.exports.roll = function(pins) {<br />
  rolls[roll] = pins;<br />
  roll++;<br />
};</p>
<p>module.exports.score = function() {<br />
  var total = 0;<br />
  var ball = 0;</p>
<p>  var isStrike = function() { return rolls[ball] == 10; };<br />
  var strikeBonus = function() { return rolls[ball + 1] + rolls[ball + 2]; };<br />
  // other helpers</p>
<p>  for (var frame = 0; frame &lt; 10; frame++) {<br />
    // omitted, the scoring algorithm itself<br />
  }<br />
  return total;<br />
};<br />
[/code]</p>
<p>I've removed the algorithm in case you'd like to code it yourself. I will say it took quite a while to get the hang of all the parentheses and curly bracket nesting. Before doing this kata, I didn't often touch JavaScript and would often mess this up the first time. Afterward, it became natural.</p>
<p>I did have some trouble understanding how modules expose methods and variables until I read <a href="http://blog.liangzan.net/blog/2012/06/04/how-to-use-exports-in-nodejs/">How to Use Exports in NodeJS</a>, which I found concise and informative.</p>
<p>After I got this kata under my belt, I started doing more research and getting interested in the <a href="http://www.mean.io/">MEAN stack</a> (MongoDB, Express, AngularJS, and Node.js). Next time, I'll show the kata with the inclusion of Express.</p>

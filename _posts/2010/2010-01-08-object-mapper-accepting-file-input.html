---
layout: post
comments: true
title: 'Object Mapper: Accepting File Input'
date: 2010-01-08 12:06:18.000000000 -07:00
categories:
- professional
tags:
- C#
- file
- object mapper
- parsing engine
- URI
status: publish
type: post
published: true
meta:
  delicious: a:3:{s:5:"count";s:1:"0";s:9:"post_tags";s:0:"";s:4:"time";s:10:"1268952157";}
  reddit: a:2:{s:5:"count";s:1:"0";s:4:"time";s:10:"1268952162";}
  _edit_last: '1'
  _jetpack_related_posts_cache: a:1:{s:32:"8f6677c9d6b0f903e98ad32ec61f8deb";a:2:{s:7:"expires";i:1431176087;s:7:"payload";a:3:{i:0;a:1:{s:2:"id";i:336;}i:1;a:1:{s:2:"id";i:411;}i:2;a:1:{s:2:"id";i:416;}}}}
author:
  login: Chuck
  email: chuck@neontapir.com
  display_name: Chuck
  first_name: Chuck
  last_name: Durfee
excerpt: !ruby/object:Hpricot::Doc
  options: {}
---
<p>The work on the Object Mapper is nearly complete from when we left off with the <a href="http://neontapir.wordpress.com/2010/01/06/the-object-mappers-conversion-engine/">conversion engine</a>. </p>
<p>I did enhance the parsing engine, though. My co-worker was trying to consume the engine, so he was reading in his document and extracting the text. We decided this was a common enough activity it would be worth adding to the parsing engine.</p>
<p>I didn't want to pass in the filename as a string, because it would mean that the parsing engine would also become responsible for determining if a string contained a filename or an XML string. One rule of thumb is to avoid using primitives like strings to represent concepts -- things with rules -- like filenames. Instead, create a class to be the custodian of that knowledge.</p>
<p>The .NET Framework already has such a class, System.Uri. The nice thing about using a URI is that any network location can also be used, not just a filename, and I get some simple validation capability.</p>
<p>Integrating the URI was easy. The parsing engine wraps the input string into a StringReader and creates an XmlReader from that with which to do its work. And really, any TextReader would do, which made the enhancement easy.  I created an overload that accepts a URI and wraps it in a StreamReader, which is also a TextReader. Problem solved!</p>
